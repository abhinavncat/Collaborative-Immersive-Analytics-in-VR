"""
This module was generated by Vizconnect.
Version: 1.03
Generated on: 2014-03-17 10:44:55.466000
"""

import viz
import vizconnect

#################################
# Parent configuration, if any
#################################

def getParentConfiguration():
	#VC: set the parent configuration
	_parent = ''
	
	#VC: return the parent configuration
	return _parent


#################################
# Pre viz.go() Code
#################################

def preVizGo():
	return True


#################################
# Pre-initialization Code
#################################

def preInit():
	"""Add any code here which should be called after viz.go but before any initializations happen.
	Returned values can be obtained by calling getPreInitResult for this file's vizconnect.Configuration instance."""
	return None


#################################
# Group Code
#################################

def initGroups(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawGroup = vizconnect.getRawGroupDict()

	#VC: initialize a new group
	_name = 'cave_manual_configuration'
	if vizconnect.isPendingInit('group', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			rawGroup[_name] = viz.addGroup()
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addGroup(rawGroup[_name], _name, make='Virtual', model='Origin')
	
		#VC: set the parent of the node
		if initFlag&vizconnect.INIT_PARENTS:
			vizconnect.getGroup(_name).setParent(vizconnect.getTransport('main_transport'))

	#VC: return values can be modified here
	return None

#################################
# Display Code
#################################

def initDisplays(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawDisplay = vizconnect.getRawDisplayDict()

	#VC: initialize a new display
	_name = 'cave_manual_configuration'
	if vizconnect.isPendingInit('display', _name, initFlag, initList):
		#VC: init which needs to happen before viz.go
		if initFlag&vizconnect.INIT_PREVIZGO:
			viz.setOption('viz.stereo', viz.QUAD_BUFFER)
			viz.setOption('viz.fullscreen', 1)
	
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set the window for the display
			_window = viz.MainWindow
			
			#VC: set some parameters
			frontWall = 2
			rightWall = 3
			backWall = -1
			leftWall = 1
			floor = 4
			ceiling = -1
			frontImageWidth = 3.84
			imageHeight = 2.39
			imageRise = 0
			originLeft = 2.2733
			originRight = 2.2733
			sideImageWidth = 0
			shiftRight = 0
			shiftUp = 0
			shiftForward = 0
			stereo = viz.QUAD_BUFFER
			frontWallSwapStereo = False
			rightWallSwapStereo = False
			backWallSwapStereo = False
			leftWallSwapStereo = False
			floorSwapStereo = False
			ceilingSwapStereo = False
			
			#VC: create the raw object
			# Create a cave object
			import vizcave
			cave = vizcave.Cave(stereo=stereo)
			
			# get an origin node
			originName = _name
			initGroups(vizconnect.INIT_INDEPENDENT, [originName])# ensure it's been created
			originNode = vizconnect.getGroup(originName).getNode3d()
			
			if sideImageWidth == 0:
				sideImageWidth = frontImageWidth
			
			# extra configuration options to more explicitly control which wall goes where.
			frontWallClientIndex=-1
			rightWallClientIndex=-1
			backWallClientIndex=-1
			leftWallClientIndex=-1
			floorClientIndex=-1
			ceilingClientIndex=-1
			
			# get the originLeft angle from the origin measurements
			import math
			aOR = math.pi/4.0
			aAOR = (originRight**2 - originLeft**2 - frontImageWidth**2)/(-2*originLeft*frontImageWidth)
			if abs(aAOR) <= 1:
				aOR = math.acos(aAOR)
			
			# convert the angle to front and right shifts
			Sr =-(math.cos(aOR)*originLeft-frontImageWidth/2.0)
			Sf = (math.sin(aOR)*originLeft-sideImageWidth/2.0)
			
			# find left/right, up/down, front/back (x,y,z) extent of caves
			R = frontImageWidth/2.0+Sr+shiftRight# right
			L =-frontImageWidth/2.0+Sr+shiftRight# left
			U = imageRise+imageHeight+shiftUp# up/top
			D = imageRise+shiftUp# bottom/down
			F = sideImageWidth/2.0+Sf+shiftForward# front
			B =-sideImageWidth/2.0+Sf+shiftForward# back
			
			# find corners
			# e.g.
			# Front Wall: C1,C2,C5,C6
			# Left  Wall: C0,C1,C4,C5
			# Right Wall: C2,C3,C6,C7
			C0 = L, U, B
			C1 = L, U, F
			C2 = R, U, F
			C3 = R, U, B
			C4 = L, D, B
			C5 = L, D, F
			C6 = R, D, F
			C7 = R, D, B
			
			clients = 0
			
			#Create front wall
			if frontWall >= 0:
				wall = vizcave.Wall(	upperLeft=C1,
										upperRight=C2,
										lowerLeft=C5,
										lowerRight=C6,
										name='Front Wall' )
			
				if frontWallClientIndex == -1:
					frontWallClientIndex = clients
				cave.addWall(wall, mask=2**frontWallClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**frontWallClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(frontWall)
					_window.setStereoSwap(frontWallSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			#Create right wall
			if rightWall >= 0:
				wall = vizcave.Wall(	upperLeft=C2,
										upperRight=C3,
										lowerLeft=C6,
										lowerRight=C7,
										name='Right Wall' )
			
				if rightWallClientIndex == -1:
					rightWallClientIndex = clients
				cave.addWall(wall, mask=2**rightWallClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**rightWallClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(rightWall)
					_window.setStereoSwap(rightWallSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			#Create back wall
			if backWall >= 0:
				wall = vizcave.Wall(	upperLeft=C3,
										upperRight=C0,
										lowerLeft=C7,
										lowerRight=C4,
										name='Back Wall' )
			
				if backWallClientIndex == -1:
					backWallClientIndex = clients
				cave.addWall(wall, mask=2**backWallClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**backWallClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(backWall)
					_window.setStereoSwap(backWallSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			#Create left wall
			if leftWall >= 0:
				wall = vizcave.Wall(	upperLeft=C0,
										upperRight=C1,
										lowerLeft=C4,
										lowerRight=C5,
										name='Left Wall' )
			
				leftWallClientIndex = clients
				cave.addWall(wall, mask=2**leftWallClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**leftWallClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(leftWall)
					_window.setStereoSwap(leftWallSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			#Create floor
			if floor >= 0:
				wall = vizcave.Wall(	upperLeft=C5,
										upperRight=C6,
										lowerLeft=C4,
										lowerRight=C7,
										name='Floor' )
			
				floorClientIndex = clients
				cave.addWall(wall, mask=2**floorClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**floorClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(floor)
					_window.setStereoSwap(floorSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			#Create ceiling
			if ceiling >= 0:
				wall = vizcave.Wall(	upperLeft=C0,
										upperRight=C3,
										lowerLeft=C1,
										lowerRight=C2,
										name='Ceiling' )
			
				ceilingClientIndex = clients
				cave.addWall(wall, mask=2**ceilingClientIndex, window=_window)
			
				with viz.cluster.MaskedContext(2**ceilingClientIndex):
					# check if the fullscreen monitor is defined.
					viz.window.setFullscreenMonitor(ceiling)
					_window.setStereoSwap(ceilingSwapStereo)
					viz.window.setFullscreen(True)
				clients += 1
			
			# We need to pass an object which will be used to update the projection
			# or the display to the view's position, typically this would be the
			# node attached to an avatar's head tracker.
			viewpoint = viz.addGroup()
			cave.setTracker(viewpoint)
			
			# Create a CaveView object for manipulating the entire cave environment.
			# The caveView is a node that can be adjusted to move the entire
			# cave around the virtual environment.
			caveView = vizcave.CaveView(viewpoint)
			
			_window.originLink = viz.link(originNode, caveView, dstFlag=viz.ABS_GLOBAL, srcFlag=viz.ABS_GLOBAL)
			_window.caveView = caveView
			_window.originNode = originNode
			_window.displayNode = cave
			_window.viewpointNode = viewpoint
			
			rawDisplay[_name] = _window
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addDisplay(rawDisplay[_name], _name, make='Generic', model='Cave Manual Configuration')
	
		#VC: set the parent of the node
		if initFlag&vizconnect.INIT_PARENTS:
			vizconnect.getDisplay(_name).setParent(vizconnect.getAvatar('main_avatar').getAttachmentPoint('head'))

	#VC: return values can be modified here
	return None


#################################
# Tracker Code
#################################

def initTrackers(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawTracker = vizconnect.getRawTrackerDict()

	#VC: initialize a new tracker
	_name = 'head_tracker'
	if vizconnect.isPendingInit('tracker', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			pptHostname = 'localhost'
			markerId = 1
			
			#VC: create the raw object
			vrpn7 = viz.add('vrpn7.dle')
			rawTracker[_name] = vrpn7.addTracker('PPT0@'+pptHostname, markerId-1)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addTracker(rawTracker[_name], _name, make='WorldViz', model='PPT')
	
		#VC: init the offsets
		if initFlag&vizconnect.INIT_OFFSETS:
			_link = vizconnect.getTracker(_name).getLink()
			#VC: clear link offsets
			_link.reset(viz.RESET_OPERATORS)
			
			#VC: apply offsets
			_link.preTrans([0, -0.04, -0.04])

	#VC: initialize a new tracker
	_name = 'r_hand_tracker'
	if vizconnect.isPendingInit('tracker', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			pptHostname = 'localhost'
			markerId = 3
			port = 0
			
			#VC: create the raw object
			# add wand tracker
			from vizconnect.util.input import viz_wand_2013
			wandsensor = viz_wand_2013.add(port=port)
			wandsensor.usedByTracker = True
			orientationTracker = wandsensor.getOrientationTracker()
			# add ppt
			vrpn7 = viz.add('vrpn7.dle')
			pptTracker = vrpn7.addTracker('PPT0@'+pptHostname, markerId-1)
			# make a merged tracker
			rawTracker[_name] = viz.mergeLinkable(pptTracker, orientationTracker)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addTracker(rawTracker[_name], _name, make='WorldViz', model='Wand 2013 Local Ori with PPT')
	
		#VC: init the offsets
		if initFlag&vizconnect.INIT_OFFSETS:
			_link = vizconnect.getTracker(_name).getLink()
			#VC: clear link offsets
			_link.reset(viz.RESET_OPERATORS)
			
			#VC: apply offsets
			_link.preTrans([0.05, 0, -0.14])
	
		#VC: init the mappings for the wrapper
		if initFlag&vizconnect.INIT_WRAPPER_MAPPINGS:
			#VC: on-state mappings
			if initFlag&vizconnect.INIT_MAPPINGS_ON_STATE:
				vizconnect.getTracker(_name).setOnStateEventList([
						vizconnect.onstate(lambda rawInput: rawInput['r_hand_input'].isButtonDown(0) and\
				rawInput['r_hand_input'].isButtonDown(6), vizconnect.getTracker(_name).resetHeading),# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Analog Button (along with) make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Trigger Button
				])

	#VC: return values can be modified here
	return None


#################################
# Input Code
#################################

def initInputs(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawInput = vizconnect.getRawInputDict()

	#VC: initialize a new input
	_name = 'r_hand_input'
	if vizconnect.isPendingInit('input', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			port = 0
			
			#VC: create the raw object
			from vizconnect.util.input import viz_wand_2013
			wandSensor = viz_wand_2013.add(port=port)
			wandSensor.usedByInput = True
			rawInput[_name] = wandSensor
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addInput(rawInput[_name], _name, make='WorldViz', model='PPT Wand 2013 Local')

	#VC: initialize a new input
	_name = 'keyboard'
	if vizconnect.isPendingInit('input', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			index = 0
			
			#VC: create the raw object
			d = viz.add('directinput.dle')
			device = d.getKeyboardDevices()[index]
			rawInput[_name] = d.addKeyboard(device)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addInput(rawInput[_name], _name, make='Generic', model='Keyboard')

	#VC: return values can be modified here
	return None


#################################
# Event Code
#################################

def initEvents(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
				#VC: place any general initialization code here
	rawEvent = vizconnect.getRawEventDict()

		#VC: initialize a new event
	_name = 'TOGGLE_PLATFORM'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'TOGGLE_PIT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(3):# make=Generic, model=Keyboard, name=keyboard, signal=Key 2
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'CAMERA_ZOOM_IN'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(23):# make=Generic, model=Keyboard, name=keyboard, signal=Key I
						event.sendEvent(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'CAMERA_ZOOM_OUT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(24):# make=Generic, model=Keyboard, name=keyboard, signal=Key O
						event.sendEvent(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'ENABLE/DISABLE_TRANSPORT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(70):# make=Generic, model=Keyboard, name=keyboard, signal=Key SCROLL_LOCK
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'PREVIOUS_MODEL'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'NEXT_MODEL'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(3):# make=Generic, model=Keyboard, name=keyboard, signal=Key 2
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'CLEAR_DRAWINGS'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'RESET_THE_BOXES'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'RESET_THE_KITCHEN_LAYOUT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'RESET_THE_LOFT_LAYOUT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'CHANGE_FLOORING'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(3):# make=Generic, model=Keyboard, name=keyboard, signal=Key 2
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'PROCEED'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(3):# make=Generic, model=Keyboard, name=keyboard, signal=Key 2
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'SHOW/HIDE_BOUNDARIES'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'RESTART_EXPERIMENT'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(199):# make=Generic, model=Keyboard, name=keyboard, signal=Key HOME
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'RESTORE_MODEL'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(2):# make=Generic, model=Keyboard, name=keyboard, signal=Key 1
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'CROSS_SECTION'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(57):# make=Generic, model=Keyboard, name=keyboard, signal=Key SPACE
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'Toggle_Walls'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(57):# make=Generic, model=Keyboard, name=keyboard, signal=Key SPACE
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: initialize a new event
	_name = 'reset_hvac_furniture'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(19):# make=Generic, model=Keyboard, name=keyboard, signal=Key R
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')
			
	#VC: initialize a new event
	_name = 'TOGGLE_LAYERS'
	if vizconnect.isPendingInit('event', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from vizconnect.util import events
			rawEvent[_name] = events.CustomEvent(viz.getEventID(_name))
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(event):
					if rawInput['keyboard'].isButtonDown(20):# make=Generic, model=Keyboard, name=keyboard, signal=Key T
						event.sendOnce(e=viz.Event(mag=1))
				rawEvent[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addEvent(rawEvent[_name], _name, make='Vizconnect', model='Custom')

	#VC: return values can be modified here
	return None


#################################
# Transport Code
#################################

def initTransports(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawTransport = vizconnect.getRawTransportDict()

	#VC: initialize a new transport
	_name = 'main_transport'
	if vizconnect.isPendingInit('transport', _name, initFlag, initList):
		#VC: request that any dependencies be created
		if initFlag&vizconnect.INIT_INDEPENDENT:
			initTrackers(vizconnect.INIT_INDEPENDENT, ['head_tracker'])
	
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			orientationTracker = vizconnect.getTracker('head_tracker').getNode3d()
			debug = False
			acceleration = 4
			maxSpeed = 2
			rotationAcceleration = 90
			maxRotationSpeed = 120
			autoBreakingDragCoef = 0.1
			dragCoef = 0.0001
			rotationAutoBreakingDragCoef = 0.2
			rotationDragCoef = 0.0001
			usingPhysics = False
			parentedTracker = False
			transportationGroup = None
			
			#VC: create the raw object
			from transportation import wand_magic_carpet
			rawTransport[_name] = wand_magic_carpet.WandMagicCarpet(	orientationTracker=orientationTracker,
																					debug=debug,
																					acceleration=acceleration,
																					maxSpeed=maxSpeed,
																					rotationAcceleration=rotationAcceleration,
																					maxRotationSpeed=maxRotationSpeed,
																					autoBreakingDragCoef=autoBreakingDragCoef,
																					dragCoef=dragCoef,
																					rotationAutoBreakingDragCoef=rotationAutoBreakingDragCoef,
																					rotationDragCoef=rotationDragCoef,
																					usingPhysics=usingPhysics,
																					parentedTracker=parentedTracker,
																					node=transportationGroup)
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(transport):
					if rawInput['r_hand_input'].isButtonDown(3):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Left Button
						transport.moveLeft(mag=1.0)
					if rawInput['r_hand_input'].isButtonDown(4):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Right Button
						transport.moveRight(mag=1.0)
					if rawInput['r_hand_input'].isButtonDown(2):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Bottom Button
						transport.moveDown(mag=1.0)
					if rawInput['r_hand_input'].isButtonDown(1):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Top Button
						transport.moveUp(mag=1.0)
					if rawInput['r_hand_input'].getJoystickPosition()[1] > 0.05:# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Analog Down
						transport.moveBackward(mag=1.0)
					if rawInput['r_hand_input'].getJoystickPosition()[1] < -0.05:# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Analog Up
						transport.moveForward(mag=1.0)
					if rawInput['r_hand_input'].getJoystickPosition()[0] < -0.05:# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Analog Left
						transport.turnLeft(mag=1.0)
					if rawInput['r_hand_input'].getJoystickPosition()[0] > 0.05:# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Analog Right
						transport.turnRight(mag=1.0)
				rawTransport[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addTransport(rawTransport[_name], _name, make='Virtual', model='WandMagicCarpet')
	
		#VC: set the pivot of the node
		if initFlag&vizconnect.INIT_PIVOTS:
			vizconnect.getTransport(_name).setPivot(vizconnect.getAvatar('main_avatar').getAttachmentPoint('head').getNode3d())

	#VC: set the name of the default
	vizconnect.setDefault('transport', 'main_transport')

	#VC: return values can be modified here
	return None


#################################
# Tool Code
#################################

def initTools(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawTool = vizconnect.getRawToolDict()

	#VC: initialize a new tool
	_name = 'proxy'
	if vizconnect.isPendingInit('tool', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: create the raw object
			from tools import proxy
			rawTool[_name] = proxy.Proxy()
	
		#VC: init the mappings for the raw object
		if initFlag&vizconnect.INIT_MAPPINGS:
			#VC: per frame mappings
			if initFlag&vizconnect.INIT_MAPPINGS_PER_FRAME:
				#VC: get the raw input dict so we have access to signals
				import vizact
				rawInput = vizconnect.getConfiguration().getRawDict('input')
				#VC: set the update function which checks for input signals
				def update(tool):
					if rawInput['r_hand_input'].isButtonDown(6):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Trigger Button
						tool.action1()
				rawTool[_name].setUpdateFunction(update)
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addTool(rawTool[_name], _name, make='Virtual', model='Proxy')
	
		#VC: set the parent of the node
		if initFlag&vizconnect.INIT_PARENTS:
			vizconnect.getTool(_name).setParent(vizconnect.getAvatar('main_avatar').getAttachmentPoint('r_hand'))

	#VC: return values can be modified here
	return None


#################################
# Avatar Code
#################################

def initAvatars(initFlag=vizconnect.INIT_INDEPENDENT, initList=None):
	#VC: place any general initialization code here
	rawAvatar = vizconnect.getRawAvatarDict()

	#VC: initialize a new avatar
	_name = 'main_avatar'
	if vizconnect.isPendingInit('avatar', _name, initFlag, initList):
		#VC: init the raw object
		if initFlag&vizconnect.INIT_RAW:
			#VC: set some parameters
			head = False
			rightHand = True
			leftHand = False
			torso = False
			lowerBody = False
			rightArm = False
			leftArm = False
			
			#VC: create the raw object
			# base avatar
			import vizfx
			avatar = vizfx.addChild('mark.cfg')
			avatar._bodyPartDict = {}
			avatar._handModelDict = {}
			avatar.visible(head, r'mark_head.cmf')
			avatar.visible(rightHand, r'mark_hand_r.cmf')
			avatar.visible(leftHand, r'mark_hand_l.cmf')
			avatar.visible(torso, r'mark_torso.cmf')
			avatar.visible(lowerBody, r'mark_legs.cmf')
			avatar.visible(rightArm, r'mark_arm_r.cmf')
			avatar.visible(leftArm, r'mark_arm_l.cmf')
			rawAvatar[_name] = avatar
	
		#VC: init the wrapper (DO NOT EDIT)
		if initFlag&vizconnect.INIT_WRAPPERS:
			vizconnect.addAvatar(rawAvatar[_name], _name, make='WorldViz', model='Mark')
	
		#VC: init the gestures
		if initFlag&vizconnect.INIT_GESTURES:
			#VC: need to get the raw input dict so we have access to signals
			import vizact
			rawInput = vizconnect.getConfiguration().getRawDict('input')
			
			#VC: gestures for the avatar's r_hand
			import hand
			def initHand():
				sensor = hand.InputSensor()
				rawAvatar[_name].handSensor = sensor
				sensor.createHandRenderer = lambda *args,**kw: hand._InputDeviceRenderer(*args,**kw)
				def appliedGetData():
					#VC: set the mappings for the gestures
					if rawInput['r_hand_input'].isButtonDown(6):# make=WorldViz, model=PPT Wand 2013 Local, name=r_hand_input, signal=Trigger Button
						return (hand.GESTURE_FIST, False, False)# GESTURE_FIST
					#VC: end gesture mappings
					return (hand.GESTURE_FLAT_HAND,False,False)
				sensor.getData = appliedGetData
				return hand.AvatarHandModel(rawAvatar[_name], left=False, type=hand.GLOVE_5DT, sensor=sensor)
			rightHand = initHand()
			rawAvatar[_name]._bodyPartDict[vizconnect.AVATAR_R_HAND] = rightHand
			rawAvatar[_name]._handModelDict[vizconnect.AVATAR_R_HAND] = rightHand
			
			#VC: gestures may change the raw avatar, so refresh the raw in the wrapper
			vizconnect.getAvatar(_name).setRaw(rawAvatar[_name])
	
		#VC: init the animator
		if initFlag&vizconnect.INIT_ANIMATOR:
			# need to get the raw tracker dict for animating the avatars
			from vizconnect.util.avatar import animator
			from vizconnect.util.avatar import skeleton
			
			# get the skeleton from the avatar
			_skeleton = skeleton.CompleteCharactersHD(rawAvatar[_name])
			
			#VC: set which trackers animate which body part
			# format is: bone: (tracker, parent, degrees of freedom used)
			_trackerAssignmentDict = {
				vizconnect.AVATAR_HEAD:(vizconnect.getTracker('head_tracker').getNode3d(), None, vizconnect.DOF_6DOF),
				vizconnect.AVATAR_R_HAND:(vizconnect.getTracker('r_hand_tracker').getNode3d(), None, vizconnect.DOF_6DOF),
			}
			
			#VC: create the raw object
			_rawAnimator = animator.Direct(rawAvatar[_name], _skeleton, _trackerAssignmentDict)
			
			#VC: set animator in wrapper (DO NOT EDIT)
			vizconnect.getAvatar(_name).setAnimator(_rawAnimator, make='Virtual', model='Direct')
	
		#VC: set the parent of the node
		if initFlag&vizconnect.INIT_PARENTS:
			vizconnect.getAvatar(_name).setParent(vizconnect.getGroup('cave_manual_configuration'))

	#VC: set the name of the default
	vizconnect.setDefault('avatar', 'main_avatar')

	#VC: return values can be modified here
	return None


#################################
# Application Settings
#################################

def initSettings():
	#VC: apply general application settings
	viz.mouse.setTrap(False)
	viz.mouse.setVisible(viz.MOUSE_AUTO_HIDE)
	vizconnect.setMouseTrapToggleKey('')
	
	#VC: return values can be modified here
	return None


#################################
# Post-initialization Code
#################################

def postInit():
	"""Add any code here which should be called after all of the initialization of this configuration is complete.
	Returned values can be obtained by calling getPostInitResult for this file's vizconnect.Configuration instance."""
	return None


#################################
# Stand alone configuration
#################################

def initInterface():
	#VC: start the interface
	vizconnect.interface.go(__file__,
							live=True,
							openBrowserWindow=True,
							startingInterface=vizconnect.interface.INTERFACE_ADVANCED)

	#VC: return values can be modified here
	return None


###############################################

if __name__ == "__main__":
	initInterface()
	viz.add('piazza.osgb')
	viz.add('piazza_animations.osgb')

